
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/jhoffmann/go-database-mcp/cmd/server/main.go (13.6%)</option>
				
				<option value="file1">github.com/jhoffmann/go-database-mcp/internal/config/loader.go (90.0%)</option>
				
				<option value="file2">github.com/jhoffmann/go-database-mcp/internal/database/connection.go (81.4%)</option>
				
				<option value="file3">github.com/jhoffmann/go-database-mcp/internal/database/mysql.go (22.9%)</option>
				
				<option value="file4">github.com/jhoffmann/go-database-mcp/internal/database/postgres.go (21.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package main provides the entry point for the Database MCP Server.
// It implements a Model Context Protocol server that provides database connectivity
// for MySQL and PostgreSQL databases via stdio transport.
package main

import (
        "context"
        "log"
        "os/signal"
        "syscall"

        "github.com/jhoffmann/go-database-mcp/internal/config"

        "github.com/modelcontextprotocol/go-sdk/mcp"
)

// Server represents the Database MCP Server instance.
// It wraps the MCP server implementation with database-specific configuration
// and provides lifecycle management.
type Server struct {
        config *config.Config // Database configuration
        server *mcp.Server    // MCP server instance
}

// NewServer creates a new Database MCP Server instance with the given configuration.
// It initializes the MCP server implementation with database-specific tools and handlers.
func NewServer(cfg *config.Config) *Server <span class="cov8" title="1">{
        impl := &amp;mcp.Implementation{
                Name:    "database-mcp",
                Version: "1.0.0",
        }

        mcpServer := mcp.NewServer(impl, nil)

        return &amp;Server{
                config: cfg,
                server: mcpServer,
        }
}</span>

// Start begins serving MCP requests using stdio transport.
// It establishes database connections and starts the MCP server to handle client requests.
// The server will run until the context is cancelled or an error occurs.
func (s *Server) Start(ctx context.Context) error <span class="cov0" title="0">{
        transport := &amp;mcp.StdioTransport{}

        log.Printf("Starting Database MCP Server...")
        log.Printf("Database type: %s", s.config.Database.Type)
        log.Printf("Database host: %s:%d", s.config.Database.Host, s.config.Database.Port)

        return s.server.Run(ctx, transport)
}</span>

// main is the entry point for the Database MCP Server.
// It loads configuration, initializes the server, and handles graceful shutdown
// on SIGINT and SIGTERM signals.
func main() <span class="cov0" title="0">{
        log.SetFlags(log.LstdFlags | log.Lshortfile)
        log.Println("Starting Database MCP Server...")

        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Configuration loaded successfully")
        log.Printf("Database type: %s", cfg.Database.Type)
        log.Printf("Database host: %s:%d", cfg.Database.Host, cfg.Database.Port)

        server := NewServer(cfg)

        ctx, cancel := signal.NotifyContext(context.Background(),
                syscall.SIGINT, syscall.SIGTERM)
        defer cancel()

        if err := server.Start(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Server error: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Server stopped gracefully")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"

        "github.com/joho/godotenv"
        "github.com/kelseyhightower/envconfig"
)

// Load reads configuration from environment variables and .env file.
// It first loads variables from .env file if present, then processes environment variables
// which take precedence over .env file values. The configuration is validated before returning.
// Returns an error if loading or validation fails.
func Load() (*Config, error) <span class="cov8" title="1">{
        if _, err := os.Stat(".env"); err == nil </span><span class="cov0" title="0">{
                if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error loading .env file: %w", err)
                }</span>
        }

        <span class="cov8" title="1">cfg := &amp;Config{
                Database: DatabaseConfig{
                        Type:         "postgres",
                        Host:         "localhost",
                        Port:         5432,
                        Database:     "",
                        Username:     "",
                        Password:     "",
                        MaxConns:     10,
                        MaxIdleConns: 5,
                        SSLMode:      "prefer",
                },
        }

        if err := envconfig.Process("", &amp;cfg.Database); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error processing database config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := Validate(cfg); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("configuration validation failed: %w", err)
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

// Validate checks the configuration for required fields and valid values.
// It ensures database type is supported, connection parameters are valid,
// and SSL modes are appropriate for the selected database type.
// Returns an error describing any validation failures.
func Validate(cfg *Config) error <span class="cov8" title="1">{
        if cfg.Database.Type != "mysql" &amp;&amp; cfg.Database.Type != "postgres" </span><span class="cov8" title="1">{
                return fmt.Errorf("database type must be 'mysql' or 'postgres', got '%s'", cfg.Database.Type)
        }</span>

        <span class="cov8" title="1">if cfg.Database.Host == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database host is required")
        }</span>

        <span class="cov8" title="1">if cfg.Database.Port &lt;= 0 || cfg.Database.Port &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("database port must be between 1 and 65535, got %d", cfg.Database.Port)
        }</span>

        <span class="cov8" title="1">if cfg.Database.Database == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database name is required")
        }</span>

        <span class="cov8" title="1">if cfg.Database.Username == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database username is required")
        }</span>

        <span class="cov8" title="1">if cfg.Database.MaxConns &lt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("max connections must be at least 1, got %d", cfg.Database.MaxConns)
        }</span>

        <span class="cov8" title="1">if cfg.Database.MaxIdleConns &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("max idle connections cannot be negative, got %d", cfg.Database.MaxIdleConns)
        }</span>

        <span class="cov8" title="1">if cfg.Database.MaxIdleConns &gt; cfg.Database.MaxConns </span><span class="cov8" title="1">{
                return fmt.Errorf("max idle connections (%d) cannot exceed max connections (%d)",
                        cfg.Database.MaxIdleConns, cfg.Database.MaxConns)
        }</span>

        <span class="cov8" title="1">if cfg.Database.Type == "postgres" </span><span class="cov8" title="1">{
                validSSLModes := map[string]bool{
                        "disable":     true,
                        "require":     true,
                        "verify-ca":   true,
                        "verify-full": true,
                        "prefer":      true,
                }
                if !validSSLModes[cfg.Database.SSLMode] </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid SSL mode for postgres: %s", cfg.Database.SSLMode)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        _ "github.com/go-sql-driver/mysql"
        "github.com/jhoffmann/go-database-mcp/internal/config"
        _ "github.com/lib/pq"
)

// Manager handles database connections and provides a factory for creating database instances.
// It supports both MySQL and PostgreSQL databases with connection pooling and SSL configuration.
type Manager struct {
        config   config.DatabaseConfig // Database configuration settings
        database Database              // Active database connection instance
}

// NewManager creates a new database manager with the given configuration.
// It validates the configuration but does not establish a connection until Connect is called.
// Returns an error if the configuration is invalid.
func NewManager(cfg config.DatabaseConfig) (*Manager, error) <span class="cov8" title="1">{
        if err := validateConfig(cfg); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid database configuration: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Manager{
                config: cfg,
        }, nil</span>
}

// Connect establishes a connection to the database based on the configured database type.
// It creates the appropriate database instance (MySQL or PostgreSQL) and connects to it.
// Returns an error if the database type is unsupported or if the connection fails.
func (m *Manager) Connect(ctx context.Context) error <span class="cov8" title="1">{
        var db Database
        var err error

        switch m.config.Type </span>{
        case "mysql":<span class="cov8" title="1">
                db, err = NewMySQL(m.config)</span>
        case "postgres":<span class="cov8" title="1">
                db, err = NewPostgreSQL(m.config)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported database type: %s", m.config.Type)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create database instance: %w", err)
        }</span>

        <span class="cov8" title="1">if err := db.Connect(ctx); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        <span class="cov0" title="0">m.database = db
        return nil</span>
}

// GetDatabase returns the active database connection instance.
// Returns nil if no connection has been established yet.
func (m *Manager) GetDatabase() Database <span class="cov8" title="1">{
        return m.database
}</span>

// Close closes the database connection and releases associated resources.
// It's safe to call even if no connection has been established.
func (m *Manager) Close() error <span class="cov8" title="1">{
        if m.database != nil </span><span class="cov0" title="0">{
                return m.database.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Ping verifies the database connection is still alive and accessible.
// Returns an error if no connection has been established or if the database is unreachable.
func (m *Manager) Ping(ctx context.Context) error <span class="cov8" title="1">{
        if m.database == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no database connection established")
        }</span>
        <span class="cov0" title="0">return m.database.Ping(ctx)</span>
}

// validateConfig validates the database configuration settings.
// It checks that all required fields are present and that the database type is supported.
// Returns an error describing any validation failures.
func validateConfig(cfg config.DatabaseConfig) error <span class="cov8" title="1">{
        if cfg.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database type is required")
        }</span>
        <span class="cov8" title="1">if cfg.Type != "mysql" &amp;&amp; cfg.Type != "postgres" </span><span class="cov8" title="1">{
                return fmt.Errorf("unsupported database type: %s", cfg.Type)
        }</span>
        <span class="cov8" title="1">if cfg.Host == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database host is required")
        }</span>
        <span class="cov8" title="1">if cfg.Port == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("database port is required")
        }</span>
        <span class="cov8" title="1">if cfg.Database == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database name is required")
        }</span>
        <span class="cov8" title="1">if cfg.Username == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("database username is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// configureConnectionPool sets up connection pooling parameters for the database connection.
// It uses configuration values if provided, otherwise applies sensible defaults:
// - MaxOpenConns: 25 connections
// - MaxIdleConns: 5 connections
// - ConnMaxLifetime: 5 minutes
// - ConnMaxIdleTime: 30 seconds
func configureConnectionPool(db *sql.DB, cfg config.DatabaseConfig) <span class="cov8" title="1">{
        if cfg.MaxConns &gt; 0 </span><span class="cov8" title="1">{
                db.SetMaxOpenConns(cfg.MaxConns)
        }</span> else<span class="cov0" title="0"> {
                db.SetMaxOpenConns(25)
        }</span>

        <span class="cov8" title="1">if cfg.MaxIdleConns &gt; 0 </span><span class="cov8" title="1">{
                db.SetMaxIdleConns(cfg.MaxIdleConns)
        }</span> else<span class="cov0" title="0"> {
                db.SetMaxIdleConns(5)
        }</span>

        <span class="cov8" title="1">db.SetConnMaxLifetime(5 * time.Minute)
        db.SetConnMaxIdleTime(30 * time.Second)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "strconv"
        "strings"

        "github.com/jhoffmann/go-database-mcp/internal/config"
)

// MySQL implements the Database interface for MySQL database connections.
// It provides MySQL-specific implementations of database operations including
// schema introspection, data access, and query execution with SSL support.
type MySQL struct {
        db     *sql.DB               // The underlying database connection
        config config.DatabaseConfig // Configuration settings for the connection
}

// NewMySQL creates a new MySQL database instance with the given configuration.
// The connection is not established until Connect() is called.
func NewMySQL(cfg config.DatabaseConfig) (*MySQL, error) <span class="cov8" title="1">{
        return &amp;MySQL{
                config: cfg,
        }, nil
}</span>

// Connect establishes a connection to the MySQL database.
// It builds the DSN from configuration, opens the connection, configures the connection pool,
// and verifies connectivity with a ping. Returns an error if any step fails.
func (m *MySQL) Connect(ctx context.Context) error <span class="cov8" title="1">{
        dsn := m.buildDSN()

        db, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open MySQL connection: %w", err)
        }</span>

        <span class="cov8" title="1">configureConnectionPool(db, m.config)

        if err := db.PingContext(ctx); err != nil </span><span class="cov8" title="1">{
                db.Close()
                return fmt.Errorf("failed to ping MySQL database: %w", err)
        }</span>

        <span class="cov0" title="0">m.db = db
        return nil</span>
}

// Close closes the MySQL database connection and releases associated resources.
// It's safe to call even if no connection has been established.
func (m *MySQL) Close() error <span class="cov8" title="1">{
        if m.db != nil </span><span class="cov0" title="0">{
                return m.db.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Ping verifies that the MySQL database connection is still alive and accessible.
// Returns an error if no connection exists or if the database is unreachable.
func (m *MySQL) Ping(ctx context.Context) error <span class="cov8" title="1">{
        if m.db == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no database connection")
        }</span>
        <span class="cov0" title="0">return m.db.PingContext(ctx)</span>
}

// Query executes a SQL query that returns rows, typically a SELECT statement.
// It supports parameter binding to prevent SQL injection attacks.
func (m *MySQL) Query(ctx context.Context, query string, args ...any) (*sql.Rows, error) <span class="cov8" title="1">{
        if m.db == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no database connection")
        }</span>
        <span class="cov0" title="0">return m.db.QueryContext(ctx, query, args...)</span>
}

// QueryRow executes a SQL query that is expected to return at most one row.
// It supports parameter binding to prevent SQL injection attacks.
func (m *MySQL) QueryRow(ctx context.Context, query string, args ...any) *sql.Row <span class="cov0" title="0">{
        return m.db.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a SQL statement that doesn't return rows, such as INSERT, UPDATE, or DELETE.
// It supports parameter binding to prevent SQL injection attacks.
// Returns a Result containing information about the execution.
func (m *MySQL) Exec(ctx context.Context, query string, args ...any) (sql.Result, error) <span class="cov8" title="1">{
        if m.db == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no database connection")
        }</span>
        <span class="cov0" title="0">return m.db.ExecContext(ctx, query, args...)</span>
}

// ListTables returns a list of all table names in the current MySQL database.
// Uses the SHOW TABLES command to retrieve table names.
func (m *MySQL) ListTables(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        query := "SHOW TABLES"
        rows, err := m.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tables: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := rows.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan table name: %w", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        <span class="cov0" title="0">return tables, rows.Err()</span>
}

// ListDatabases returns a list of all available database names on the MySQL server.
// Uses the SHOW DATABASES command to retrieve database names.
func (m *MySQL) ListDatabases(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        query := "SHOW DATABASES"
        rows, err := m.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list databases: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var databases []string
        for rows.Next() </span><span class="cov0" title="0">{
                var dbName string
                if err := rows.Scan(&amp;dbName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan database name: %w", err)
                }</span>
                <span class="cov0" title="0">databases = append(databases, dbName)</span>
        }

        <span class="cov0" title="0">return databases, rows.Err()</span>
}

// DescribeTable returns detailed schema information about the specified MySQL table.
// It retrieves column definitions, data types, constraints, and index information
// using the INFORMATION_SCHEMA tables.
func (m *MySQL) DescribeTable(ctx context.Context, tableName string) (*TableSchema, error) <span class="cov0" title="0">{
        schema := &amp;TableSchema{
                TableName: tableName,
                Columns:   []ColumnInfo{},
                Indexes:   []IndexInfo{},
                Metadata:  make(map[string]any),
        }

        query := `
                SELECT 
                        COLUMN_NAME,
                        DATA_TYPE,
                        IS_NULLABLE,
                        COLUMN_DEFAULT,
                        COLUMN_KEY,
                        EXTRA,
                        CHARACTER_MAXIMUM_LENGTH
                FROM INFORMATION_SCHEMA.COLUMNS 
                WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
                ORDER BY ORDINAL_POSITION`

        rows, err := m.Query(ctx, query, m.config.Database, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to describe table: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var column ColumnInfo
                var nullable, columnKey, extra string
                var defaultValue, maxLength sql.NullString

                err := rows.Scan(
                        &amp;column.Name,
                        &amp;column.Type,
                        &amp;nullable,
                        &amp;defaultValue,
                        &amp;columnKey,
                        &amp;extra,
                        &amp;maxLength,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan column info: %w", err)
                }</span>

                <span class="cov0" title="0">column.IsNullable = nullable == "YES"
                column.IsPrimaryKey = columnKey == "PRI"
                column.IsAutoIncrement = strings.Contains(extra, "auto_increment")

                if defaultValue.Valid </span><span class="cov0" title="0">{
                        column.DefaultValue = &amp;defaultValue.String
                }</span>

                <span class="cov0" title="0">if maxLength.Valid </span><span class="cov0" title="0">{
                        if length, err := strconv.Atoi(maxLength.String); err == nil </span><span class="cov0" title="0">{
                                column.MaxLength = &amp;length
                        }</span>
                }

                <span class="cov0" title="0">schema.Columns = append(schema.Columns, column)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading column data: %w", err)
        }</span>

        <span class="cov0" title="0">indexQuery := `
                SELECT 
                        INDEX_NAME,
                        COLUMN_NAME,
                        NON_UNIQUE
                FROM INFORMATION_SCHEMA.STATISTICS 
                WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
                ORDER BY INDEX_NAME, SEQ_IN_INDEX`

        indexRows, err := m.Query(ctx, indexQuery, m.config.Database, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get index info: %w", err)
        }</span>
        <span class="cov0" title="0">defer indexRows.Close()

        indexMap := make(map[string]*IndexInfo)
        for indexRows.Next() </span><span class="cov0" title="0">{
                var indexName, columnName string
                var nonUnique int

                err := indexRows.Scan(&amp;indexName, &amp;columnName, &amp;nonUnique)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan index info: %w", err)
                }</span>

                <span class="cov0" title="0">if index, exists := indexMap[indexName]; exists </span><span class="cov0" title="0">{
                        index.Columns = append(index.Columns, columnName)
                }</span> else<span class="cov0" title="0"> {
                        indexMap[indexName] = &amp;IndexInfo{
                                Name:      indexName,
                                Columns:   []string{columnName},
                                IsUnique:  nonUnique == 0,
                                IsPrimary: indexName == "PRIMARY",
                        }
                }</span>
        }

        <span class="cov0" title="0">for _, index := range indexMap </span><span class="cov0" title="0">{
                schema.Indexes = append(schema.Indexes, *index)
        }</span>

        <span class="cov0" title="0">return schema, nil</span>
}

// GetTableData retrieves data from the specified MySQL table with pagination support.
// If limit is 0 or negative, it defaults to 100 rows. The method also returns
// the total row count for pagination purposes.
func (m *MySQL) GetTableData(ctx context.Context, tableName string, limit int, offset int) (*TableData, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">countQuery := fmt.Sprintf("SELECT COUNT(*) FROM `%s`", tableName)
        var total int
        err := m.QueryRow(ctx, countQuery).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count rows: %w", err)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("SELECT * FROM `%s` LIMIT ? OFFSET ?", tableName)
        rows, err := m.Query(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query table data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov0" title="0">data := &amp;TableData{
                TableName: tableName,
                Columns:   columns,
                Rows:      []map[string]any{},
                Total:     total,
                Limit:     limit,
                Offset:    offset,
        }

        for rows.Next() </span><span class="cov0" title="0">{
                values := make([]any, len(columns))
                valuePtrs := make([]any, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">err := rows.Scan(valuePtrs...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                <span class="cov0" title="0">row := make(map[string]any)
                for i, col := range columns </span><span class="cov0" title="0">{
                        if values[i] != nil </span><span class="cov0" title="0">{
                                row[col] = values[i]
                        }</span> else<span class="cov0" title="0"> {
                                row[col] = nil
                        }</span>
                }
                <span class="cov0" title="0">data.Rows = append(data.Rows, row)</span>
        }

        <span class="cov0" title="0">return data, rows.Err()</span>
}

// ExplainQuery returns the execution plan for the given SQL query in JSON format.
// Uses MySQL's EXPLAIN FORMAT=JSON command to provide detailed query analysis.
func (m *MySQL) ExplainQuery(ctx context.Context, query string) (string, error) <span class="cov0" title="0">{
        explainQuery := fmt.Sprintf("EXPLAIN FORMAT=JSON %s", query)
        var result string
        err := m.QueryRow(ctx, explainQuery).Scan(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to explain query: %w", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// GetDB returns the underlying *sql.DB instance for direct database operations.
// Returns nil if no connection has been established.
func (m *MySQL) GetDB() *sql.DB <span class="cov8" title="1">{
        return m.db
}</span>

// GetDriverName returns the name of the database driver.
// Always returns "mysql" for MySQL connections.
func (m *MySQL) GetDriverName() string <span class="cov8" title="1">{
        return "mysql"
}</span>

// buildDSN constructs a MySQL Data Source Name (DSN) from the configuration.
// It includes SSL configuration, timeout settings, and other connection parameters
// required for establishing a secure and reliable MySQL connection.
func (m *MySQL) buildDSN() string <span class="cov8" title="1">{
        var params []string

        if m.config.SSLMode != "" </span><span class="cov8" title="1">{
                switch m.config.SSLMode </span>{
                case "none":<span class="cov8" title="1">
                        params = append(params, "tls=false")</span>
                case "required":<span class="cov8" title="1">
                        params = append(params, "tls=true")</span>
                case "preferred":<span class="cov8" title="1">
                        params = append(params, "tls=preferred")</span>
                default:<span class="cov8" title="1">
                        params = append(params, "tls=true")</span>
                }
        }

        <span class="cov8" title="1">params = append(params, "parseTime=true")
        params = append(params, "timeout=30s")
        params = append(params, "readTimeout=30s")
        params = append(params, "writeTimeout=30s")

        dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s",
                m.config.Username,
                m.config.Password,
                m.config.Host,
                m.config.Port,
                m.config.Database,
        )

        if len(params) &gt; 0 </span><span class="cov8" title="1">{
                dsn += "?" + strings.Join(params, "&amp;")
        }</span>

        <span class="cov8" title="1">return dsn</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "strconv"
        "strings"

        "github.com/jhoffmann/go-database-mcp/internal/config"
)

// PostgreSQL implements the Database interface for PostgreSQL database connections.
// It provides PostgreSQL-specific implementations of database operations including
// schema introspection, data access, and query execution with SSL support.
type PostgreSQL struct {
        db     *sql.DB               // The underlying database connection
        config config.DatabaseConfig // Configuration settings for the connection
}

// NewPostgreSQL creates a new PostgreSQL database instance with the given configuration.
// The connection is not established until Connect() is called.
func NewPostgreSQL(cfg config.DatabaseConfig) (*PostgreSQL, error) <span class="cov8" title="1">{
        return &amp;PostgreSQL{
                config: cfg,
        }, nil
}</span>

// Connect establishes a connection to the PostgreSQL database.
// It builds the DSN from configuration, opens the connection, configures the connection pool,
// and verifies connectivity with a ping. Returns an error if any step fails.
func (p *PostgreSQL) Connect(ctx context.Context) error <span class="cov8" title="1">{
        dsn := p.buildDSN()

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open PostgreSQL connection: %w", err)
        }</span>

        <span class="cov8" title="1">configureConnectionPool(db, p.config)

        if err := db.PingContext(ctx); err != nil </span><span class="cov8" title="1">{
                db.Close()
                return fmt.Errorf("failed to ping PostgreSQL database: %w", err)
        }</span>

        <span class="cov0" title="0">p.db = db
        return nil</span>
}

// Close closes the PostgreSQL database connection and releases associated resources.
// It's safe to call even if no connection has been established.
func (p *PostgreSQL) Close() error <span class="cov8" title="1">{
        if p.db != nil </span><span class="cov0" title="0">{
                return p.db.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Ping verifies that the PostgreSQL database connection is still alive and accessible.
// Returns an error if no connection exists or if the database is unreachable.
func (p *PostgreSQL) Ping(ctx context.Context) error <span class="cov8" title="1">{
        if p.db == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no database connection")
        }</span>
        <span class="cov0" title="0">return p.db.PingContext(ctx)</span>
}

// Query executes a SQL query that returns rows, typically a SELECT statement.
// It supports parameter binding to prevent SQL injection attacks.
func (p *PostgreSQL) Query(ctx context.Context, query string, args ...any) (*sql.Rows, error) <span class="cov8" title="1">{
        if p.db == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no database connection")
        }</span>
        <span class="cov0" title="0">return p.db.QueryContext(ctx, query, args...)</span>
}

// QueryRow executes a SQL query that is expected to return at most one row.
// It supports parameter binding to prevent SQL injection attacks.
func (p *PostgreSQL) QueryRow(ctx context.Context, query string, args ...any) *sql.Row <span class="cov0" title="0">{
        return p.db.QueryRowContext(ctx, query, args...)
}</span>

// Exec executes a SQL statement that doesn't return rows, such as INSERT, UPDATE, or DELETE.
// It supports parameter binding to prevent SQL injection attacks.
// Returns a Result containing information about the execution.
func (p *PostgreSQL) Exec(ctx context.Context, query string, args ...any) (sql.Result, error) <span class="cov8" title="1">{
        if p.db == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no database connection")
        }</span>
        <span class="cov0" title="0">return p.db.ExecContext(ctx, query, args...)</span>
}

// ListTables returns a list of all table names in the current PostgreSQL database.
// Queries the information_schema.tables view for tables in the 'public' schema.
func (p *PostgreSQL) ListTables(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        query := `
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
                ORDER BY table_name`

        rows, err := p.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tables: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := rows.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan table name: %w", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        <span class="cov0" title="0">return tables, rows.Err()</span>
}

// ListDatabases returns a list of all available database names on the PostgreSQL server.
// Queries the pg_database system catalog, excluding template databases.
func (p *PostgreSQL) ListDatabases(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        query := `
                SELECT datname 
                FROM pg_database 
                WHERE datistemplate = false
                ORDER BY datname`

        rows, err := p.Query(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list databases: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var databases []string
        for rows.Next() </span><span class="cov0" title="0">{
                var dbName string
                if err := rows.Scan(&amp;dbName); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan database name: %w", err)
                }</span>
                <span class="cov0" title="0">databases = append(databases, dbName)</span>
        }

        <span class="cov0" title="0">return databases, rows.Err()</span>
}

// DescribeTable returns detailed schema information about the specified PostgreSQL table.
// It retrieves column definitions, data types, constraints, and index information
// using the information_schema views and system catalogs.
func (p *PostgreSQL) DescribeTable(ctx context.Context, tableName string) (*TableSchema, error) <span class="cov0" title="0">{
        schema := &amp;TableSchema{
                TableName: tableName,
                Columns:   []ColumnInfo{},
                Indexes:   []IndexInfo{},
                Metadata:  make(map[string]any),
        }

        query := `
                SELECT 
                        c.column_name,
                        c.data_type,
                        c.is_nullable,
                        c.column_default,
                        c.character_maximum_length,
                        CASE WHEN pk.column_name IS NOT NULL THEN true ELSE false END as is_primary_key,
                        CASE WHEN c.column_default LIKE 'nextval%' THEN true ELSE false END as is_auto_increment
                FROM information_schema.columns c
                LEFT JOIN (
                        SELECT k.column_name
                        FROM information_schema.table_constraints t
                        JOIN information_schema.key_column_usage k ON t.constraint_name = k.constraint_name
                        WHERE t.constraint_type = 'PRIMARY KEY' 
                                AND t.table_name = $1 AND k.table_name = $1
                ) pk ON c.column_name = pk.column_name
                WHERE c.table_name = $1 AND c.table_schema = 'public'
                ORDER BY c.ordinal_position`

        rows, err := p.Query(ctx, query, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to describe table: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        for rows.Next() </span><span class="cov0" title="0">{
                var column ColumnInfo
                var nullable string
                var defaultValue, maxLength sql.NullString
                var isPrimaryKey, isAutoIncrement bool

                err := rows.Scan(
                        &amp;column.Name,
                        &amp;column.Type,
                        &amp;nullable,
                        &amp;defaultValue,
                        &amp;maxLength,
                        &amp;isPrimaryKey,
                        &amp;isAutoIncrement,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan column info: %w", err)
                }</span>

                <span class="cov0" title="0">column.IsNullable = nullable == "YES"
                column.IsPrimaryKey = isPrimaryKey
                column.IsAutoIncrement = isAutoIncrement

                if defaultValue.Valid </span><span class="cov0" title="0">{
                        column.DefaultValue = &amp;defaultValue.String
                }</span>

                <span class="cov0" title="0">if maxLength.Valid </span><span class="cov0" title="0">{
                        if length, err := strconv.Atoi(maxLength.String); err == nil </span><span class="cov0" title="0">{
                                column.MaxLength = &amp;length
                        }</span>
                }

                <span class="cov0" title="0">schema.Columns = append(schema.Columns, column)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading column data: %w", err)
        }</span>

        <span class="cov0" title="0">indexQuery := `
                SELECT 
                        i.relname as index_name,
                        array_agg(a.attname ORDER BY a.attnum) as column_names,
                        ix.indisunique as is_unique,
                        ix.indisprimary as is_primary
                FROM pg_class t
                JOIN pg_index ix ON t.oid = ix.indrelid
                JOIN pg_class i ON i.oid = ix.indexrelid
                JOIN pg_attribute a ON a.attrelid = t.oid AND a.attnum = ANY(ix.indkey)
                WHERE t.relname = $1 AND t.relkind = 'r'
                GROUP BY i.relname, ix.indisunique, ix.indisprimary`

        indexRows, err := p.Query(ctx, indexQuery, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get index info: %w", err)
        }</span>
        <span class="cov0" title="0">defer indexRows.Close()

        for indexRows.Next() </span><span class="cov0" title="0">{
                var index IndexInfo
                var columnArray string

                err := indexRows.Scan(&amp;index.Name, &amp;columnArray, &amp;index.IsUnique, &amp;index.IsPrimary)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan index info: %w", err)
                }</span>

                <span class="cov0" title="0">columnArray = strings.Trim(columnArray, "{}")
                index.Columns = strings.Split(columnArray, ",")

                schema.Indexes = append(schema.Indexes, index)</span>
        }

        <span class="cov0" title="0">return schema, nil</span>
}

// GetTableData retrieves data from the specified PostgreSQL table with pagination support.
// If limit is 0 or negative, it defaults to 100 rows. The method also returns
// the total row count for pagination purposes.
func (p *PostgreSQL) GetTableData(ctx context.Context, tableName string, limit int, offset int) (*TableData, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov0" title="0">countQuery := fmt.Sprintf("SELECT COUNT(*) FROM \"%s\"", tableName)
        var total int
        err := p.QueryRow(ctx, countQuery).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count rows: %w", err)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("SELECT * FROM \"%s\" LIMIT $1 OFFSET $2", tableName)
        rows, err := p.Query(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query table data: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov0" title="0">data := &amp;TableData{
                TableName: tableName,
                Columns:   columns,
                Rows:      []map[string]any{},
                Total:     total,
                Limit:     limit,
                Offset:    offset,
        }

        for rows.Next() </span><span class="cov0" title="0">{
                values := make([]any, len(columns))
                valuePtrs := make([]any, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">err := rows.Scan(valuePtrs...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan row: %w", err)
                }</span>

                <span class="cov0" title="0">row := make(map[string]any)
                for i, col := range columns </span><span class="cov0" title="0">{
                        if values[i] != nil </span><span class="cov0" title="0">{
                                row[col] = values[i]
                        }</span> else<span class="cov0" title="0"> {
                                row[col] = nil
                        }</span>
                }
                <span class="cov0" title="0">data.Rows = append(data.Rows, row)</span>
        }

        <span class="cov0" title="0">return data, rows.Err()</span>
}

// ExplainQuery returns the execution plan for the given SQL query in JSON format.
// Uses PostgreSQL's EXPLAIN (FORMAT JSON) command to provide detailed query analysis.
func (p *PostgreSQL) ExplainQuery(ctx context.Context, query string) (string, error) <span class="cov0" title="0">{
        explainQuery := fmt.Sprintf("EXPLAIN (FORMAT JSON) %s", query)
        var result string
        err := p.QueryRow(ctx, explainQuery).Scan(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to explain query: %w", err)
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// GetDB returns the underlying *sql.DB instance for direct database operations.
// Returns nil if no connection has been established.
func (p *PostgreSQL) GetDB() *sql.DB <span class="cov8" title="1">{
        return p.db
}</span>

// GetDriverName returns the name of the database driver.
// Always returns "postgres" for PostgreSQL connections.
func (p *PostgreSQL) GetDriverName() string <span class="cov8" title="1">{
        return "postgres"
}</span>

// buildDSN constructs a PostgreSQL connection string from the configuration.
// It includes SSL configuration, timeout settings, and other connection parameters
// required for establishing a secure and reliable PostgreSQL connection.
func (p *PostgreSQL) buildDSN() string <span class="cov8" title="1">{
        var params []string

        params = append(params, fmt.Sprintf("host=%s", p.config.Host))
        params = append(params, fmt.Sprintf("port=%d", p.config.Port))
        params = append(params, fmt.Sprintf("user=%s", p.config.Username))
        params = append(params, fmt.Sprintf("password=%s", p.config.Password))
        params = append(params, fmt.Sprintf("dbname=%s", p.config.Database))

        if p.config.SSLMode != "" </span><span class="cov8" title="1">{
                params = append(params, fmt.Sprintf("sslmode=%s", p.config.SSLMode))
        }</span> else<span class="cov8" title="1"> {
                params = append(params, "sslmode=prefer")
        }</span>

        <span class="cov8" title="1">params = append(params, "connect_timeout=30")

        return strings.Join(params, " ")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
